# Linear Search â€” Theory, Realâ€‘Life Example & Code

## ğŸ” What is Linear Search
- Linear Search (Sequential Search) is a simple searching algorithm.
- It checks each element of a list/array one by one from start to end until it finds the target.
- Works on unsorted arrays â€” no need to sort.

---

## ğŸ› ï¸ How Linear Search Works â€” Pseudocode
```
procedure linear_search(list, target):
    for i from 0 to length(list)-1:
        if list[i] == target:
            return i        # target found at index i
    return -1               # target not found
```

---

## ğŸ’» JavaScript Implementation

```js
// Returns index of target if found, otherwise -1
function linearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      return i;  // target found
    }
  }
  return -1;     // not found
}

// Example use:
let arr = [10, 50, 30, 70, 80, 20];
console.log(linearSearch(arr, 70));  // 3
console.log(linearSearch(arr, 99));  // -1
```

### Variant: Return all indices (if multiple occurrences)
```js
function linearSearchAll(arr, target) {
  const indices = [];
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) indices.push(i);
  }
  return indices;
}
console.log(linearSearchAll([1,2,3,2,4], 2)); // [1,3]
```

---

## ğŸ“š Realâ€‘Life Analogy (Classroom Example)
Imagine a classroom attendance sheet with students' roll numbers in no particular order (unsorted list).

Task: Check if roll number **42** is present.

Steps (Linear Search):
1. Start at the first roll number on the sheet.
2. Compare it with 42.
3. If it matches â†’ found.
4. If not â†’ move to the next roll number.
5. Repeat until you find 42 or reach the end of the sheet.

- If the sheet is small, this is fast.
- If the sheet is large and 42 is near the end (or not present), it takes longer.
- You only need a finger (one pointer variable) to traverse â€” no extra data structures.

---

## âœ… Time & Space Complexity

| Case | Time Complexity | Explanation |
|------|-----------------|-------------|
| Best case | O(1) | Target is at the first element. |
| Worst / Average | O(n) | Target is at the end or not present; must check all elements. |
| Space Complexity | O(1) | Only constant extra space (index/variables). |

---

## ğŸ¯ When to Use Linear Search
- Data is **unsorted** and small.
- You need a quick one-off search.
- Frequent insertions/deletions happen (keeping sorted order costly).
- Simplicity over performance is acceptable.

---

## âœ… Pros and Cons

**Pros**
- Simple to implement.
- Works on unsorted data.
- Low extra memory (O(1)).

**Cons**
- Inefficient for large datasets (O(n)).
- Not suitable for frequent searches on large data (use hashing, binary search on sorted arrays, etc.).

---

## ğŸ” Example Problems to Practice
1. Find first occurrence of a value in an array.
2. Count how many times a value appears (use linearSearchAll).
3. Search in a linked list (same idea since access is sequential).
4. Check if any element satisfies a condition (e.g., isPrime) â€” use linear scan.

---

## ğŸ”§ Quick Tips (Interview)
- Mention both best and worst case time complexities.
- Explain space complexity as auxiliary space (exclude input).
- For multiple searches, recommend using a hash set/map or sorting + binary search.
- Show a variant if asked (e.g., return all indices, return boolean, or stop after first match).

---

*File generated by ChatGPT â€” use as reference or study notes.*
